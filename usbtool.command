#!/usr/bin/swift

import Cocoa

let kTargetBoard = "H97N-WIFI"
let kAppTitle = "\(kTargetBoard) USB Tool"
let kBundleName = "USBPorts"
let kBundleIdentifier = "org.usbtool.kext"
let kDriverPersonalityKey = "Generated by \(kAppTitle)"
let kDriverIONameMatch = "XHC"
let kDriverIOProviderClass = "AppleUSBXHCILPTHB"
let kFallbackModelIdentifier = "iMac18,1"
let kDefaultPortMapData: [USBPort] = [
	.init(
		name: "HS01",
		address: 0x1,
		connector: .a3,
		info: "USB 3 header"
	), .init(
		name: "HS02",
		address: 0x2,
		connector: .a3,
		info: "USB 3 header"
	), .init(
		name: "HS03",
		address: 0x3,
		connector: .a3,
		info: "Rear panel USB 3 connector"
	), .init(
		name: "HS04",
		address: 0x4,
		connector: .a3,
		info: "Rear panel USB 3 connector"
	), .init(
		name: "HS05",
		address: 0x5,
		connector: .a2,
		info: "USB 2 header"
	), .init(
		name: "HS06",
		address: 0x6,
		connector: .a2,
		info: "USB 2 header"
	), .init(
		name: "HS07",
		address: 0x7,
		connector: .a2,
		info: "Rear panel USB 2 connector"
	), .init(
		name: "HS08",
		address: 0x8,
		connector: .a2,
		info: "Rear panel USB 2 connector"
	), .init(
		name: "HS09",
		address: 0x9,
		connector: .a3,
		info: "Rear panel USB 3 connector"
	), .init(
		name: "HS10",
		address: 0xA,
		connector: .a3,
		info: "Rear panel USB 3 connector"
	), .init(
		name: "HS11",
		address: 0xB,
		connector: .proprietary,
		info: "Mini PCI express"
	), .init(
		name: "SS01",
		address: 0x10,
		connector: .a3,
		info: "USB 3 header"
	), .init(
		name: "SS02",
		address: 0x11,
		connector: .a3,
		info: "USB 3 header"
	), .init(
		name: "SS03",
		address: 0x12,
		connector: .a3,
		info: "Rear panel USB 3 connector"
	), .init(
		name: "SS04",
		address: 0x13,
		connector: .a3,
		info: "Rear panel USB 3 connector"
	), .init(
		name: "SS05",
		address: 0x14,
		connector: .a3,
		info: "Rear panel USB 3 connector"
	), .init(
		name: "SS06",
		address: 0x15,
		connector: .a3,
		info: "Rear panel USB 3 connector"
	)
]
let kInfoPlistSourceData = """
	PD94bWwgdmVyc2lvbj0iMS4wIiBlbmNvZGluZz0iVVRGLTgiPz48IURPQ1RZUEUgcGxpc3QgUFVCTElD
	ICItLy9BcHBsZS8vRFREIFBMSVNUIDEuMC8vRU4iICJodHRwOi8vd3d3LmFwcGxlLmNvbS9EVERzL1By
	b3BlcnR5TGlzdC0xLjAuZHRkIj48cGxpc3QgdmVyc2lvbj0iMS4wIj48ZGljdD48a2V5PkNGQnVuZGxl
	SW5mb0RpY3Rpb25hcnlWZXJzaW9uPC9rZXk+PHN0cmluZz42LjA8L3N0cmluZz48a2V5PkNGQnVuZGxl
	UGFja2FnZVR5cGU8L2tleT48c3RyaW5nPktFWFQ8L3N0cmluZz48a2V5PkNGQnVuZGxlU2hvcnRWZXJz
	aW9uU3RyaW5nPC9rZXk+PHN0cmluZz4xLjA8L3N0cmluZz48a2V5PkNGQnVuZGxlU3VwcG9ydGVkUGxh
	dGZvcm1zPC9rZXk+PGFycmF5PjxzdHJpbmc+TWFjT1NYPC9zdHJpbmc+PC9hcnJheT48a2V5PkNGQnVu
	ZGxlVmVyc2lvbjwva2V5PjxzdHJpbmc+MS4wPC9zdHJpbmc+PGtleT5PU0J1bmRsZVJlcXVpcmVkPC9r
	ZXk+PHN0cmluZz5Sb290PC9zdHJpbmc+PC9kaWN0PjwvcGxpc3Q+
"""
let kWindowWidth: CGFloat = 360.0
let kPortListEdgeInsets = NSEdgeInsets(top: 5.0, left: 10.0, bottom: 5.0, right: 10.0)
let kPortListColumnSpacing: CGFloat = 3.0
let kPortListRowSpacing: CGFloat = 9.0
let kContentSpacing: CGFloat = 20.0
let kWriteButtonTitle = "Write Bundle to Desktop"
let kWriteSuccessFormatString = "Wrote bundle to %@"

extension DispatchQueue {
	static let work = DispatchQueue(label: "work")
}

extension FileHandle: TextOutputStream {
	public func write(_ string: String) {
		self.write(string.data(using: .utf8)!)
	}
}

extension FileManager {
	public func directoryExists(atPath path: String) -> Bool {
		var dir = ObjCBool(false)
		return FileManager.default.fileExists(atPath: path, isDirectory: &dir) && dir.boolValue
	}
	
	public func desktopDirectoryURL() throws -> URL {
		guard let url = FileManager.default.urls(for: .desktopDirectory, in: .userDomainMask).first else {
			throw RuntimeError("failed to obtain desktop directory URL")
		}
		
		return url
	}
}

extension FixedWidthInteger {
	public var data: Data {
		var this = self
		return .init(bytes: &this, count: MemoryLayout<Self>.size)
	}
}

extension NSMenu {
	convenience init(title: String, items: [NSMenuItem]) {
		self.init(title: title)
		self.items = items
	}
}

extension NSMenuItem {
	convenience init(title: String, action: Selector? = nil) {
		self.init(title: title, action: action, keyEquivalent: "")
	}
}

struct RuntimeError: LocalizedError {
	let description: String
	let location: String
	
	init(_ description: String, location: String = #function) {
		self.description = description
		self.location = location
	}
	
	var errorDescription: String? {
		return "The operation couldn't be completed (\(String(describing: self))) \(location): \(description)"
	}
}

enum USBConnector: UInt8 {
	case a2 = 0x0 // Type A (USB 2)
	case a3 = 0x3 // Type A (USB 3)
	case c3s = 0x9 // Type C (USB 3, switched)
	case c3 = 0xA // Type C (USB 3)
	case proprietary = 0xFF // e.g. internal bluetooth
}

final class USBPort: NSObject {
	public let name: String
	public let address: UInt32
	public let connector: USBConnector
	public let info: String
	@objc private(set) var isEnabled: Bool
	
	init(name: String, address: UInt32, connector: USBConnector, info: String, isEnabled: Bool = true) {
		self.name = name
		self.address = address
		self.connector = connector
		self.info = info
		self.isEnabled = isEnabled
	}
}

final class PortMap {
	static let `default` = PortMap(data: kDefaultPortMapData)
	public let data: [USBPort]
	
	init(data: [USBPort]) {
		self.data = data
	}
	
	public var lastAddress: UInt32? {
		return data.sorted { $0.address < $1.address }.last?.address
	}
	
	public var enabledCount: Int {
		return data.filter { $0.isEnabled }.count
	}
}

struct Bundle {
	init(destination url: URL) throws {
		guard FileManager.default.directoryExists(atPath: url.path) else {
			throw RuntimeError("directory not found at destination path \(url.path)")
		}
		
		kextURL = url.appendingPathComponent("\(kBundleName).kext")
		contentsURL = kextURL.appendingPathComponent("Contents")
		plistURL = contentsURL.appendingPathComponent("Info.plist")
	}
	
	let kextURL: URL
	let contentsURL: URL
	let plistURL: URL
	
	func createDirectories() throws {
		try FileManager.default.createDirectory(atPath: contentsURL.path, withIntermediateDirectories: true, attributes: nil)
	}
	
	func updateModificationDate() throws {
		try FileManager.default.setAttributes([.modificationDate: NSDate()], ofItemAtPath: kextURL.path)
	}
	
	func writePropertyList(data: Data) throws {
		try data.write(to: plistURL, options: .atomic)
	}
}

final class BundleWriter {
	static let shared = BundleWriter()
	private let propertyList: [String: Any]
	private var errorStream = FileHandle.standardError
	
	private init() {
		do {
			propertyList = try Self.decodePropertyListFromBase64()
		}
		
		catch {
			fatalError(error.localizedDescription)
		}
	}
	
	private static func decodePropertyListFromBase64() throws -> [String: Any] {
		guard let data: Data = .init(base64Encoded: kInfoPlistSourceData, options: .ignoreUnknownCharacters) else {
			throw RuntimeError("failed to decode property list data from base64")
		}
		
		let plist: Any = try PropertyListSerialization.propertyList(from: data, options: .mutableContainersAndLeaves, format: nil)
		
		guard let result = plist as? [String: Any] else {
			throw RuntimeError("failed to cast serialized property list to dictionary")
		}
		
		return result
	}
	
	private lazy var modelIdentifier: String = {
		let entryPath = "IOService:/"
		let modelKey = "model" as CFString
		var identifier: String?
		let entry = IORegistryEntryFromPath(kIOMasterPortDefault, entryPath)
		
		if let data = IORegistryEntryCreateCFProperty(entry, modelKey, kCFAllocatorDefault, 0)?.takeRetainedValue() as? Data {
			identifier = String(data: data, encoding: .macOSRoman)?.filter { $0 != "\0"}
		}
		
		IOObjectRelease(entry)
		
		guard identifier != nil else {
			print("warning: using fallback model identifier \(kFallbackModelIdentifier)!", to: &errorStream)
			return kFallbackModelIdentifier
		}
		
		return identifier!
	}()
	
	public func write(destination url: URL, userMap: PortMap) throws -> URL {
		let bundleIdentifierKey = kCFBundleIdentifierKey as String
		let bundleNameKey = kCFBundleNameKey as String
		let driverBundleIdentifier = "com.apple.driver.AppleUSBHostMergeProperties"
		let driverClass = "AppleUSBHostMergeProperties"
		let personalitiesKey = "IOKitPersonalities"
		let providerMergePropertiesKey = "IOProviderMergeProperties"
		let modelIdentifierKey = "model"
		let portCountKey = "port-count"
		let portsKey = "ports"
		let portAddressKey = "port"
		let portConnectorKey = "UsbConnector"
		
		guard let portCount = userMap.lastAddress else {
			throw RuntimeError("userMap is empty")
		}
		
		let bundle = try Bundle(destination: url)
		var propertyList = propertyList
		var ports = [String: Any]()
		
		for port in userMap.data {
			ports[port.name] = [
				portAddressKey: port.address.data,
				portConnectorKey: port.connector.rawValue
			]
		}
		
		propertyList[bundleNameKey] = kBundleName
		propertyList[bundleIdentifierKey] = kBundleIdentifier
		propertyList[personalitiesKey] = [
			kDriverPersonalityKey: [
				bundleIdentifierKey: driverBundleIdentifier,
				kIOClassKey: driverClass,
				kIONameMatchKey: kDriverIONameMatch,
				kIOProviderClassKey: kDriverIOProviderClass,
				providerMergePropertiesKey: [
					modelIdentifierKey: modelIdentifier,
					portCountKey: portCount.data,
					portsKey: ports
				]
			]
		]

		let data = try PropertyListSerialization.data(fromPropertyList: propertyList, format: .xml, options: 0)
		try bundle.createDirectories()
		try bundle.writePropertyList(data: data)
		try? bundle.updateModificationDate()
		return bundle.kextURL
	}
}

final class ViewController: NSViewController {
	static let shared = ViewController()
	private let portLimit = 15
	private var errorStream = FileHandle.standardError
	
	private init() {
		super.init(nibName: nil, bundle: nil)
	}
	
	required init?(coder: NSCoder) {
		return nil
	}
	
	private lazy var portListView: NSGridView = {
		let view = NSGridView(numberOfColumns: 3, rows: 0)
		
		for port in PortMap.default.data {
			let button = makePortSwitchButton(title: port.name, enabled: port.isEnabled)
			button.target = self
			button.action = #selector(ViewController.switchButtonPressed(_:))
			button.bind(NSBindingName.value, to: port,
				    withKeyPath: #keyPath(USBPort.isEnabled),
				    options: [NSBindingOption.validatesImmediately: true])
			view.addRow(with: [button, makeLabel(port.info)])
		}
		
		view.rowAlignment = .firstBaseline
		view.columnSpacing = kPortListColumnSpacing
		view.rowSpacing = kPortListRowSpacing
		view.column(at: 1).xPlacement = .leading
		view.translatesAutoresizingMaskIntoConstraints = false
		return view
	}()
	
	private lazy var writeButton: NSButton = {
		let button = NSButton()
		button.translatesAutoresizingMaskIntoConstraints = false
		button.bezelStyle = .rounded
		button.title = kWriteButtonTitle
		button.isEnabled = false
		return button
	}()
	
	override func loadView() {
		view = AppDelegate.shared.mainWindow.contentView!
	}
	
	override func viewDidLoad() {
		view.window?.title = kAppTitle
		view.subviews = [portListView, writeButton]
		writeButton.target = self
		writeButton.action = #selector(ViewController.writeButtonPressed(_:))
		enableWriteButton()
		NSLayoutConstraint.activate([
			portListView.leadingAnchor.constraint(equalTo: view.leadingAnchor, constant: (kContentSpacing + kPortListEdgeInsets.left)),
			portListView.trailingAnchor.constraint(equalTo: view.trailingAnchor, constant: -(kContentSpacing + kPortListEdgeInsets.right)),
			portListView.topAnchor.constraint(equalTo: view.topAnchor, constant: (kContentSpacing + kPortListEdgeInsets.top)),
			portListView.bottomAnchor.constraint(equalTo: writeButton.topAnchor, constant: -(kContentSpacing + kPortListEdgeInsets.bottom)),
			writeButton.bottomAnchor.constraint(equalTo: view.bottomAnchor, constant: -kContentSpacing),
			writeButton.trailingAnchor.constraint(equalTo: view.trailingAnchor, constant: -kContentSpacing)
		])
	}
	
	private func enableWriteButton() {
		writeButton.isEnabled = PortMap.default.enabledCount <= portLimit
	}
	
	@objc func switchButtonPressed(_ sender: NSButton) {
		enableWriteButton()
	}
	
	@objc func writeButtonPressed(_ sender: NSButton) {
		let userMap = PortMap(data: PortMap.default.data.filter { $0.isEnabled })
		
		DispatchQueue.work.async { [userMap] in
			do {
				let desktop = try FileManager.default.desktopDirectoryURL()
				let successURL = try BundleWriter.shared.write(destination: desktop, userMap: userMap)
				print(String(format: kWriteSuccessFormatString, successURL.path))
			}
			
			catch {
				print(error.localizedDescription, to: &self.errorStream)
			}
		}
	}
	
	private func makePortSwitchButton(title: String, enabled: Bool) -> NSButton {
		let button = NSButton()
		button.title = title
		button.setButtonType(.switch)
		button.state = enabled ? .on : .off
		button.setContentHuggingPriority(.defaultLow, for: .horizontal)
		return button
	}
	
	private func makeLabel(_ stringValue: String) -> NSTextField {
		let textField = NSTextField()
		textField.drawsBackground = false
		textField.isBezeled = false
		textField.isEditable = false
		textField.textColor = NSColor.secondaryLabelColor
		textField.stringValue = stringValue
		textField.setContentHuggingPriority(.defaultHigh, for: .horizontal)
		return textField
	}
}

final class AppDelegate: NSObject, NSApplicationDelegate {
	static let shared = AppDelegate()
	
	private override init() {
		super.init()
	}
	
	public lazy var mainWindow: NSWindow = {
		let window = NSWindow()
		window.styleMask = [.titled, .closable]
		window.standardWindowButton(.miniaturizeButton)?.isHidden = true
		window.standardWindowButton(.zoomButton)?.isHidden = true
		window.contentView?.widthAnchor.constraint(greaterThanOrEqualToConstant: kWindowWidth).isActive = true
		return window
	}()
	
	private lazy var mainMenu: NSMenu = {
		let processName = ProcessInfo.processInfo.processName
		let menu = NSMenu(title: "Main Menu", items: [
			NSMenuItem(title: processName)
		])
		menu.items[0].submenu = NSMenu(title: "Application Menu", items: [
			NSMenuItem(title: "About \(processName)",
				   action: #selector(NSApplication.orderFrontStandardAboutPanel(_:))),
			NSMenuItem.separator(),
			NSMenuItem(title: "Quit \(processName)",
				   action: #selector(NSApplication.terminate(_:)),
				   keyEquivalent: "q")
		])
		return menu
	}()
	
	@objc func applicationShouldTerminateAfterLastWindowClosed(_ sender: NSApplication) -> Bool {
		return true
	}
	
	@objc func applicationDidFinishLaunching(_ notification: Notification) {
		NSApp.activate(ignoringOtherApps: true)
	}
	
	public func runApp() {
		NSApp = NSApplication.shared
		NSApp.delegate = AppDelegate.shared
		NSApp.mainMenu = mainMenu
		NSApp.setActivationPolicy(.regular)
		mainWindow.contentViewController = ViewController.shared
		mainWindow.makeKeyAndOrderFront(self)
		mainWindow.center()
		NSApp.run()
	}
}

AppDelegate.shared.runApp()
